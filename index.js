/*** Generated by streamline 0.10.8 (callbacks) --standalone - DO NOT EDIT ***/ var __rt=(function(){var __modules={},mod;function require(p){var m=__modules[p.substring(15)]; return m && m.exports};__modules['globals']=(mod={exports:{}});(function(module, exports){var glob = typeof global === "object" ? global : window;var secret = "_20c7abceb95c4eb88b7ca1895b1170d1";module.exports = (glob[secret] || (glob[secret] = { context: {} }));var g = glob[secret];g.runtime || Object.defineProperty(g, 'runtime', {get: function() { return g.__runtime__; },set: function(value) {if (g.__runtime__ !== value) {if (g.__runtime__) {if (/-fast$/.test(g.__runtime__) ||/-fast$/.test(value)) throw new Error("cannot mix streamline runtimes: " + g.__runtime__ + " and " + value);console.log("warning: mixing streamline runtimes: " + g.__runtime__ + " and " + value);}g.__runtime__ = value;}}});})(mod, mod.exports);__modules['util/future']=(mod={exports:{}});(function(module, exports){(function(exports) {exports.future = function(fn, args, i) {var err, result, done, q = [], self = this;args = Array.prototype.slice.call(args);args[i] = function(e, r) {err = e, result = r, done = true;q && q.forEach(function(f) {f.call(self, e, r);});q = null;};fn.apply(this, args);return function F(cb) {if (typeof cb !== 'function') {if (cb !== false && !require('streamline/lib/globals').oldStyleFutures) throw new Error("no callback given (argument #0). If you're a Streamline user, more info: https://github.com/Sage/streamlinejs/blob/master/FAQ.md#no-callback-given-error");return F;}if (done) cb.call(self, err, result);else q.push(cb);};};exports.streamlinify = function(fn, idx) {return function() {if (!arguments[idx]) return exports.future.call(this, fn, arguments, idx);else return fn.apply(this, arguments);};};})(typeof exports !== 'undefined' ? exports : (Streamline.future = Streamline.future || {}));})(mod, mod.exports);__modules['callbacks/runtime']=(mod={exports:{}});(function(module, exports){(function(exports) {var __g = require("streamline/lib/globals");__g.runtime = 'callbacks';var __fut = require("streamline/lib/util/future");__g.context = __g.context || {};__g.depth = __g.depth || 0;__g.trampoline = (function() {var q = [];return {queue: function(fn) {q.push(fn);},flush: function() {__g.depth++;try {var fn;while (fn = q.shift()) fn();} finally {__g.depth--;}}}})();exports.runtime = function(filename, oldStyleFutures) {__g.oldStyleFutures = oldStyleFutures;function __func(_, __this, __arguments, fn, index, frame, body) {if (typeof _ !== 'function') {if (_ !== false && !__g.oldStyleFutures) throw new Error("no callback given (argument #" + index + "). If you're a Streamline user, more info: https://github.com/Sage/streamlinejs/blob/master/FAQ.md#no-callback-given-error");return __fut.future.call(__this, fn, __arguments, index);}frame.file = filename;frame.prev = __g.frame;__g.frame = frame;__g.depth === 0 && __g.emitter && __g.emitter.emit("resume");__g.depth++;try {frame.active = true;body();} catch (e) {__setEF(e, frame.prev);__propagate(_, e);} finally {frame.active = false;__g.frame = frame.prev;if (--__g.depth === 0 && __g.trampoline) __g.trampoline.flush();__g.depth === 0 && __g.emitter && __g.emitter.emit("yield");}}return {__g: __g,__func: __func,__cb: __cb,__future: __fut.future,__propagate: __propagate,__trap: __trap,__tryCatch: __tryCatch,__catch: __catch,__forIn: __forIn,__apply: __apply,__construct: __construct,__setEF: __setEF,streamlinify: __fut.streamlinify,};};function __cb(_, frame, offset, col, fn, trampo, returnArray) {frame.offset = offset;frame.col = col;var ctx = __g.context;return function ___(err, result) {if (returnArray) result = Array.prototype.slice.call(arguments, 1);returnArray = false; var oldFrame = __g.frame;__g.frame = frame;__g.context = ctx;__g.depth === 0 && __g.emitter && __g.emitter.emit("resume");__g.depth++;try {if (trampo && frame.active && __g.trampoline) {__g.trampoline.queue(function() {return ___(err, result);});} else {___.dispatched = true;if (err) {__setEF(err, frame);return _(err);}frame.active = true;return fn(null, result);}} catch (ex) {if (___.dispatched && _.name !== '___' && _.name !== '__trap') throw ex;__setEF(ex, frame);return __propagate(_, ex);} finally {frame.active = false;__g.frame = oldFrame;if (--__g.depth === 0 && __g.trampoline) __g.trampoline.flush();__g.depth === 0 && __g.emitter && __g.emitter.emit("yield");}}}function __propagate(_, err) {try {_(err);} catch (ex) {__trap(ex);}}function __trap(err) {if (err) {if (__g.context && __g.context.errorHandler) __g.context.errorHandler(err);else process.nextTick(function() {throw err;});}}function __tryCatch(_, fn) {try {fn();} catch (e) {try {_(e);} catch (ex) {__trap(ex);}}}function __catch(fn) {var frame = __g.frame,context = __g.context;__g.trampoline.queue(function() {var oldFrame = __g.frame,oldContext = __g.context;__g.frame = frame;__g.context = context;try {fn();} finally {__g.frame = oldFrame;__g.context = oldContext;}});}function __forIn(object) {var array = [];for (var obj in object) {array.push(obj);}return array;}function __apply(cb, fn, thisObj, args, index) {if (cb == null) return __fut.future(__apply, arguments, 0);args = Array.prototype.slice.call(args, 0);args[index != null ? index : args.length] = cb;return fn.apply(thisObj, args);}function __construct(constructor, i) {var key = '__async' + i,f;return constructor[key] || (constructor[key] = function() {var args = arguments;function F() {var self = this;var cb = args[i];args[i] = function(e, r) {cb(e, self);};return constructor.apply(self, args);}F.prototype = constructor.prototype;return new F();});}function __setEF(e, f) {function formatStack(e, raw) {var ff = typeof navigator === 'object' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;if (ff) raw = "Error: " + e.message + '\n' + raw;var s = raw,f, skip;if (s) {var lines = s.split('\n');s = lines[0] + '\n    <<< async stack >>>\n' + lines.slice(1).map(function(l) {var ffOffset = (typeof navigator === 'object' && typeof require === 'function' && require.async) ? 11 : 0;var m = /([^@]*)\@(.*)\:(\d+)$/.exec(l);l = m ? "    at " + m[1] + " (" + m[2] + ":" + (parseInt(m[3]) - ffOffset) + ":0)" : l;var i = l.indexOf('__$');if (i >= 0 && !skip) {skip = true;return l.substring(0, i) + l.substring(i + 3);}return skip ? '' : l;}).filter(function(l) {return l;}).join('\n');for (var f = e.__frame; f; f = f.prev) {if (f.offset >= 0) s += "\n    at " + f.name + " (" + f.file + ":" + (f.line + f.offset) + ":" + f.col + ")"}}var nl = raw.indexOf('\n');s += '\n    <<< raw stack >>>' + (nl >= 0 ? raw.substring(nl) : raw);return s;};e.__frame = e.__frame || f;if (exports.stackTraceEnabled && e.__lookupGetter__ && e.__lookupGetter__("rawStack") == null) {var getter = e.__lookupGetter__("stack");if (!getter) { var raw = e.stack || "raw stack unavailable";getter = function() {return raw;}}e.__defineGetter__("rawStack", getter);e.__defineGetter__("stack", function() {return formatStack(e, getter());});}}exports.stackTraceEnabled = true;})(typeof exports !== 'undefined' ? exports : (Streamline.runtime = Streamline.runtime || {}));require && require("streamline/lib/callbacks/builtins");})(mod, mod.exports);return __modules['callbacks/runtime'].exports.runtime('/var/www/simongrondin/reddit/reddit-markov-chains/index._coffee', false);})(),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function() {
  var Bottleneck, con, generateBullshit, getPage, handler, http, limiter, rCaps, rURL, rWord, rand, url, util;

  Bottleneck = require("bottleneck");

  url = require("url");

  http = require("http");

  util = require("util");

  con = function() {
    return util.puts(Array.prototype.slice.call(arguments, 0).map(function(a) {
      return util.inspect(a);
    }).join(" ")); };


  rURL = new RegExp("/r/.*$");

  rWord = new RegExp("[a-zA-Z-'.:/]", "g");

  rCaps = new RegExp("[A-Z]", "");

  rand = function(s, e) {
    return ((Math.floor((Math.random() * (((e - s) + 1))))) - s); };


  Array.prototype.random = function() {
    return this[rand(0, (this.length - 1))]; };


  limiter = new Bottleneck(5, 200);

  String.prototype.fsplit = function(pred) {
    var buf, c, ret, _i, _len;
    buf = "";
    ret = [];
    for (_i = 0, _len = this.length; (_i < _len); _i++) {
      c = this[_i];
      buf += c;
      if (pred(buf)) {
        ret.push(buf.slice(0, -1));
        buf = (!pred(c) ? c : ""); } ; };


    ret.push(buf);
    return ret.filter(function(a) {
      return (a.length > 0); }); };



  getPage = function(addr, cb) {
    var data, req;
    data = "";
    req = http.request({
      hostname: "www.reddit.com",
      port: 80,
      method: "GET",
      path: addr,
      headers: {
      "user-agent": "Reddit-Node-Bot v0.1" }

    }, function(res) {
      res.on("data", function(chunk) {
        return data += chunk.toString("utf8"); });

      return res.on("end", function() {
        return cb(null, data); }); });


    req.on("error", function(err) {
      return cb(err); });

    return req.end(); };


  generateBullshit = function generateBullshit__1(addr, _) { var addReply, data, i, j, lastWord, nextWord, pairs, replies, starts, str, strs, title, top, _i; var __frame = { name: "generateBullshit__1", line: 77 }; return __func(_, this, arguments, generateBullshit__1, 1, __frame, function __$generateBullshit__1() {

      return limiter.submit(getPage, (addr + ".json"), __cb(_, __frame, 2, 22, function ___(__0, __1) { data = JSON.parse(__1);
        if ((data.error != null)) {
          return _(new Error(JSON.stringify(data))); } ;

        top = data[1].data.children;
        title = data[0].data.children[0].data.title;
        replies = [title,];
        addReply = function(post) {
          var _ref, _ref1, _ref2;
          replies.push(post.data.body);
          return (((_ref = post.data.replies) != null) ? (((_ref1 = _ref.data) != null) ? (((_ref2 = _ref1.children) != null) ? _ref2.forEach(function(c) {
            return addReply(c);
          }) : void 0) : void 0) : void 0); };

        top.forEach(function(c) {
          return addReply(c); });

        pairs = { };
        starts = [];
        replies.filter(function(r) {
          return (r != null);
        }).map(function(r) {
          return (r + (((r.slice(-1) !== ".") ? "." : "")));
        }).forEach(function(r) {
          var words;
          return words = r.fsplit(function(a) {
            return !rWord.test(a);
          }).forEach(function(w, i, words) {
            if ((i !== (words.length - 1))) {
              if (rCaps.test(w.trim()[0])) {
                starts.push(w); } ;

              if ((pairs[w] != null)) {
                return pairs[w].push(words[(i + 1)]); }
               else {
                return pairs[w] = [words[(i + 1)],]; } ; } ; }); });




        strs = [];
        for (i = _i = 1; (_i <= 10); i = ++_i) {
          str = starts.random();
          lastWord = str;
          j = 0;
          while (((lastWord.slice(-1) !== ".") && (j < 50))) {
            nextWord = pairs[lastWord].random();
            str += (" " + nextWord);
            lastWord = nextWord;
            j++; };

          strs.push(str); };

        return _(null, strs); }, true)); }); };


  handler = function handler__2(req, res, _) { var addr, err, parsed, ret; var __frame = { name: "handler__2", line: 135 }; return __func(_, this, arguments, handler__2, 2, __frame, function __$handler__2() {













      return (function ___closure(_) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$___closure() { parsed = url.parse(req.url, true); addr = parsed.pathname.match(rURL)[0]; console.log((((new Date).toISOString() + " ") + req.url)); return generateBullshit(addr, __cb(_, __frame, 5, 30, function ___(__0, __2) { var __1 = JSON.stringify(__2); return _(null, __1); }, true)); }); })(function ___(_error, __result) { __catch(function __$___closure() { if (_error) { err = _error; con(req.url); con(err); return _(null, err.message); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$___closure() { _(); }); }); })(__cb(_, __frame, 14, 10, function ___(__0, __1) { ret = __1;
        ret = ((parsed.query.callback != null) ? (((parsed.query.callback + "(") + ret) + ");") : ret);
        res.writeHead(200, {
        "Content-type": "text/json" });

        return _(null, res.end(ret)); }, true)); }); };


  http.createServer(function(req, res) {
    var err;
    try {
      return handler(req, res, function() {  });
    } catch (_error) {
      err = _error;
      con("----------------");
      con(err);
      res.end();
      return con("----------------"); };

  }).listen("./socket/reddit-markov.sock");

}).call(this);